
model {
  for (i in 1:N) {
  
    # P(T,A,U|X)=P(T|A,X,U)*P(A|X,U)*P(U|X)
    
    #  Likelihood for U (latent confounder), P(U|X), if U is dependent of X1 and X2
    U[i] ~ dbern(pU[i])
    logit(pU[i]) = alpha0 + alpha.X1 * X1[i]+ alpha.X2 * X2[i]
    
    # Treatment A, P(A|X,U)
    A[i] ~ dbern(pA[i])
    logit(pA[i]) = gamma0 + gamma.X1 * X1[i] + gamma.X2 * X2[i]+ gamma.U * U[i]
    
    # Likelihood for survival outcome T (AFT model), P(T|A,X,U)
    
    #the following contents are needed to be verified again
    #lambda is the rate parameter, not scale, so in dweib() of JAGS, lamda = exp(-mu[i]/sigma)
    # T~weibull(shape=1/sigma, rate= exp(-mu[i]/sigma))
    #T[i] ~ dweib(shape, lambda[i])   Weibull survival time, dweib(shape, rate)
    
    #Weibull T~weibull(shape=1/sigma, lambda(rate)= exp(-mu[i]/sigma))
    T[i] ~ dweib(shape, lambda[i])
    lambda[i] = exp(-mu[i] / sigma)
    mu[i] = beta0 + beta.A * A[i] + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * U[i]
  }

for (i in 1:N) {
    # spce;
    # U is independent of A
    # predicted potential mu under A=1 and A=0
    # Posterior predictive SPCE
    pUpo[i] = ilogit(alpha0 + alpha.X1 * X1[i]+ alpha.X2 * X2[i])
    U.po[i] ~ dbern(pUpo[i])
    
    #should sample U
    mu1po[i] <- beta0 + beta.A * 1 + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * U.po[i]
    mu0po[i] <- beta0 + beta.A * 0 + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * U.po[i]
    
    #Expected value  E[U[i]]=pU[i], wrong?
    # mu1[i] = beta0 + beta.A*1 + beta.X1*X1[i] + beta.X2*X2[i] + beta.U*pU[i]
    # mu0[i] = beta0 + beta.A*0 + beta.X1*X1[i] + beta.X2*X2[i] + beta.U*pU[i]


    lambda1po[i] = exp(-mu1po[i]/sigma)
    lambda0po[i] = exp(-mu0po[i]/sigma)
    
    S1[i] = exp(-(lambda1po[i]*t_pred)^shape)
    S0[i] = exp(-(lambda0po[i]*t_pred)^shape)
    
    #log-normal aft, not weibull aft
    # S1[i] <- 1 - phi((log(t_pred) - mu1po[i])/sigma)
    # S0[i] <- 1 - phi((log(t_pred) - mu0po[i])/sigma)
    
    
     
    # True SPCE (marginalize over U=0 and U=1)
    mu1_u1[i] = beta0 + beta.A * 1 + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * 1
    mu1_u0[i] = beta0 + beta.A * 1 + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * 0
    mu0_u1[i] = beta0 + beta.A * 0 + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * 1
    mu0_u0[i] = beta0 + beta.A * 0 + beta.X1 * X1[i] + beta.X2 * X2[i] + beta.U * 0

    lambda1_u1[i] = exp(-mu1_u1[i] / sigma)
    lambda1_u0[i] = exp(-mu1_u0[i] / sigma)
    lambda0_u1[i] = exp(-mu0_u1[i] / sigma)
    lambda0_u0[i] = exp(-mu0_u0[i] / sigma)

    S1_true[i] = pUpo[i] * exp(-pow(lambda1_u1[i] * t_pred, shape)) +
                 (1 - pUpo[i]) * exp(-pow(lambda1_u0[i] * t_pred, shape))

    S0_true[i] = pUpo[i] * exp(-pow(lambda0_u1[i] * t_pred, shape)) +
                 (1 - pUpo[i]) * exp(-pow(lambda0_u0[i] * t_pred, shape))
  }

  
  spce = mean(S1[])-mean(S0[])
  spce_true = mean(S1_true[]) - mean(S0_true[])
  
  # Priors for parameters
  sigma ~ dunif(0.01, 10)
  shape = 1/sigma
  
  gamma0 ~ dnorm(0, 0.01)
  gamma.X1 ~ dnorm(0, 0.01)
  gamma.X2 ~ dnorm(0, 0.01)
  
  beta0 ~ dnorm(0, 0.01)
  beta.A ~ dnorm(0, 0.01)
  beta.X1 ~ dnorm(0, 0.01)
  beta.X2 ~ dnorm(0, 0.01)
  
  #bias parameters
  gamma.U ~ dunif(-5,5)
  alpha0 ~ dunif(-5,5)
  alpha.X1 ~ dunif(-5,5)
  alpha.X2 ~ dunif(-5,5)
  beta.U ~ dunif(-5,5)

}
 